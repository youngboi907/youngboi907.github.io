<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Delta Monitor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f8f9fa; padding: 20px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .card { margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .positive { color: #28a745; }
        .negative { color: #dc3545; }
        .candle-chart-container { height: 200px; margin-bottom: 15px; }
        #connection-status {
            position: fixed; bottom: 10px; right: 10px;
            padding: 5px 10px; border-radius: 3px;
            font-size: 0.8rem;
        }
        .connected { background-color: #28a745; color: white; }
        .disconnected { background-color: #dc3545; color: white; }
        .reconnecting { background-color: #ffc107; color: black; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center my-4">BTC/USDT Delta Monitor</h1>
        
        <div class="row mb-4">
            <div class="col-12">
                <div class="btn-group w-100">
                    <button id="spot-btn" class="btn btn-outline-primary active">Spot</button>
                    <button id="futures-btn" class="btn btn-outline-primary">Futures</button>
                </div>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Current Delta</div>
                    <div class="card-body text-center">
                        <div id="current-delta" class="h3">--</div>
                        <div class="row mt-3">
                            <div class="col-6">
                                <div id="delta-buy" class="h4 positive">--</div>
                                <div>Buy Volume</div>
                            </div>
                            <div class="col-6">
                                <div id="delta-sell" class="h4 negative">--</div>
                                <div>Sell Volume</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Current Window</div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-6 text-center">
                                <div id="max-delta" class="h4 positive">--</div>
                                <div>Max Delta</div>
                            </div>
                            <div class="col-6 text-center">
                                <div id="min-delta" class="h4 negative">--</div>
                                <div>Min Delta</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mt-4">
            <div class="card-header">Timeframe Candles</div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <h5>5 Minute</h5>
                        <div class="candle-chart-container">
                            <canvas id="5mChart"></canvas>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>15 Minute</h5>
                        <div class="candle-chart-container">
                            <canvas id="15mChart"></canvas>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>1 Hour</h5>
                        <div class="candle-chart-container">
                            <canvas id="1hChart"></canvas>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>4 Hour</h5>
                        <div class="candle-chart-container">
                            <canvas id="4hChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="connection-status" class="disconnected">Disconnected</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-financial"></script>
    <script>
        // Configuration
        const CONFIG = {
            symbol: 'btcusdt',
            endpoints: {
                spot: [
                    'wss://stream.binance.com:9443/ws/btcusdt@aggTrade',
                    'wss://stream.binance.com:443/ws/btcusdt@aggTrade'
                ],
                futures: [
                    'wss://fstream.binance.com/ws/btcusdt@aggTrade',
                    'wss://fstream.binance.com:443/ws/btcusdt@aggTrade'
                ]
            },
            timeframes: {
                '5m': 5 * 60 * 1000,
                '15m': 15 * 60 * 1000,
                '1h': 60 * 60 * 1000,
                '4h': 4 * 60 * 60 * 1000
            }
        };

        // Application State
        const state = {
            market: 'spot',
            websocket: null,
            trades: [],
            candles: {},
            currentStats: {},
            charts: {},
            reconnectAttempts: 0,
            maxReconnectAttempts: 5
        };

        // Initialize the application
        function init() {
            // Initialize data structures
            Object.keys(CONFIG.timeframes).forEach(tf => {
                state.candles[tf] = [];
                state.currentStats[tf] = createNewWindowStats();
            });

            // Setup UI elements
            setupEventListeners();
            setupCharts();
            connectWebSocket();
        }

        function createNewWindowStats() {
            return {
                windowStart: null,
                buy: 0,
                sell: 0,
                max: -Infinity,
                min: Infinity
            };
        }

        // WebSocket Management
        function connectWebSocket() {
            // Close existing connection
            if (state.websocket) {
                state.websocket.close();
            }

            updateStatus('Connecting...', 'reconnecting');
            
            const endpoint = CONFIG.endpoints[state.market][0];
            state.websocket = new WebSocket(endpoint);

            state.websocket.onopen = () => {
                updateStatus('Connected', 'connected');
                state.reconnectAttempts = 0;
                console.log('WebSocket connected to:', endpoint);
            };

            state.websocket.onmessage = (event) => {
                try {
                    const trade = JSON.parse(event.data);
                    processTrade(trade);
                } catch (e) {
                    console.error('Error processing trade:', e);
                }
            };

            state.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                tryFallback();
            };

            state.websocket.onclose = () => {
                if (state.reconnectAttempts < state.maxReconnectAttempts) {
                    updateStatus('Reconnecting...', 'reconnecting');
                    state.reconnectAttempts++;
                    setTimeout(connectWebSocket, 3000);
                } else {
                    updateStatus('Disconnected', 'disconnected');
                }
            };
        }

        function tryFallback() {
            updateStatus('Trying fallback...', 'reconnecting');
            const fallbackUrl = CONFIG.endpoints[state.market][1];
            console.log('Attempting fallback to:', fallbackUrl);
            
            state.websocket = new WebSocket(fallbackUrl);
            
            state.websocket.onopen = () => {
                updateStatus('Connected (fallback)', 'connected');
                state.reconnectAttempts = 0;
            };
            state.websocket.onerror = () => {
                setTimeout(connectWebSocket, 5000);
            };
        }

        // Trade Processing
        function processTrade(trade) {
            // Store the trade
            const tradeData = {
                timestamp: new Date(trade.T),
                value: parseFloat(trade.q) * parseFloat(trade.p),
                isBuy: !trade.m
            };
            state.trades.push(tradeData);

            // Update all timeframes
            Object.keys(CONFIG.timeframes).forEach(tf => {
                updateTimeframeStats(tf, tradeData);
            });

            updateUI();
        }

        function updateTimeframeStats(timeframe, trade) {
            const windowSize = CONFIG.timeframes[timeframe];
            const windowStart = new Date(Math.floor(trade.timestamp / windowSize) * windowSize);
            const stats = state.currentStats[timeframe];

            // Check if we're in a new window
            if (!stats.windowStart || windowStart > stats.windowStart) {
                // If we had previous data, create a candle
                if (stats.windowStart) {
                    createCandle(timeframe);
                }
                
                // Reset stats for new window
                state.currentStats[timeframe] = createNewWindowStats();
                state.currentStats[timeframe].windowStart = windowStart;
            }

            // Update volumes
            if (trade.isBuy) {
                state.currentStats[timeframe].buy += trade.value;
            } else {
                state.currentStats[timeframe].sell += trade.value;
            }

            // Update min/max delta
            const delta = state.currentStats[timeframe].buy - state.currentStats[timeframe].sell;
            state.currentStats[timeframe].max = Math.max(delta, state.currentStats[timeframe].max);
            state.currentStats[timeframe].min = Math.min(delta, state.currentStats[timeframe].min);
        }

        function createCandle(timeframe) {
            const stats = state.currentStats[timeframe];
            const delta = stats.buy - stats.sell;

            state.candles[timeframe].push({
                x: stats.windowStart.getTime(),
                o: delta,
                h: stats.max,
                l: stats.min,
                c: delta,
                s: delta >= 0 ? 'rgba(40, 167, 69, 0.8)' : 'rgba(220, 53, 69, 0.8)'
            });

            // Keep only last 20 candles
            if (state.candles[timeframe].length > 20) {
                state.candles[timeframe].shift();
            }

            updateChart(timeframe);
        }

        // Chart Management
        function setupCharts() {
            Object.keys(CONFIG.timeframes).forEach(tf => {
                const ctx = document.getElementById(`${tf}Chart`).getContext('2d');
                state.charts[tf] = new Chart(ctx, {
                    type: 'candlestick',
                    data: {
                        datasets: [{
                            label: tf,
                            data: []
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value, true);
                                    }
                                }
                            },
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: {
                                        minute: 'HH:mm'
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }

        function updateChart(timeframe) {
            state.charts[timeframe].data.datasets[0].data = state.candles[timeframe];
            state.charts[timeframe].update();
        }

        // UI Updates
        function updateUI() {
            // Get latest trade window (5m)
            const stats = state.currentStats['5m'];
            const delta = stats.buy - stats.sell;

            // Update current values
            document.getElementById('current-delta').textContent = formatCurrency(delta);
            document.getElementById('current-delta').className = `h3 ${delta >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('delta-buy').textContent = formatCurrency(stats.buy);
            document.getElementById('delta-sell').textContent = formatCurrency(stats.sell);
            
            // Update min/max
            document.getElementById('max-delta').textContent = formatCurrency(stats.max);
            document.getElementById('min-delta').textContent = formatCurrency(stats.min);
        }

        function updateStatus(text, status = 'disconnected') {
            const el = document.getElementById('connection-status');
            el.textContent = text;
            el.className = status;
        }

        // Helper Functions
        function formatCurrency(value, short = false) {
            if (value === undefined || value === null) return '--';
            if (short) {
                if (Math.abs(value) >= 1000000) return '$' + (value/1000000).toFixed(1) + 'M';
                if (Math.abs(value) >= 1000) return '$' + (value/1000).toFixed(1) + 'K';
            }
            return '$' + Math.round(value);
        }

        // Event Listeners
        function setupEventListeners() {
            document.getElementById('spot-btn').addEventListener('click', () => {
                state.market = 'spot';
                document.getElementById('spot-btn').classList.add('active');
                document.getElementById('futures-btn').classList.remove('active');
                resetData();
                connectWebSocket();
            });

            document.getElementById('futures-btn').addEventListener('click', () => {
                state.market = 'futures';
                document.getElementById('futures-btn').classList.add('active');
                document.getElementById('spot-btn').classList.remove('active');
                resetData();
                connectWebSocket();
            });
        }

        function resetData() {
            state.trades = [];
            Object.keys(CONFIG.timeframes).forEach(tf => {
                state.candles[tf] = [];
                state.currentStats[tf] = createNewWindowStats();
                state.charts[tf].data.datasets[0].data = [];
                state.charts[tf].update();
            });
        }

        // Start the application
        init();
    </script>
</body>
</html>