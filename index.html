<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Delta Monitor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .card {
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: none;
        }
        .positive { color: #28a745; }
        .negative { color: #dc3545; }
        .candle-chart-container { 
            height: 200px; 
            margin-bottom: 15px;
            width: 100%;
        }
        #connection-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.8rem;
        }
        .connected { background-color: #28a745; color: white; }
        .disconnected { background-color: #dc3545; color: white; }
        .reconnecting { background-color: #ffc107; color: black; }
        .delta-value { font-size: 2rem; font-weight: bold; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center my-4">BTC/USDT Delta Monitor</h1>
        
        <div class="row mb-4">
            <div class="col-12">
                <div class="btn-group w-100">
                    <button id="spot-btn" class="btn btn-outline-primary active">Spot</button>
                    <button id="futures-btn" class="btn btn-outline-primary">Futures</button>
                </div>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Current Delta</div>
                    <div class="card-body text-center">
                        <div id="current-delta" class="delta-value">--</div>
                        <div class="row mt-3">
                            <div class="col-6">
                                <div id="delta-buy" class="stat-value positive">--</div>
                                <div>Buy Volume</div>
                            </div>
                            <div class="col-6">
                                <div id="delta-sell" class="stat-value negative">--</div>
                                <div>Sell Volume</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Current Window</div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-6 text-center">
                                <div id="max-delta" class="stat-value positive">--</div>
                                <div>Max Delta</div>
                            </div>
                            <div class="col-6 text-center">
                                <div id="min-delta" class="stat-value negative">--</div>
                                <div>Min Delta</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mt-4">
            <div class="card-header">Timeframe Candles</div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <h5>5 Minute</h5>
                        <div class="candle-chart-container">
                            <canvas id="5mChart"></canvas>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>15 Minute</h5>
                        <div class="candle-chart-container">
                            <canvas id="15mChart"></canvas>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>1 Hour</h5>
                        <div class="candle-chart-container">
                            <canvas id="1hChart"></canvas>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>4 Hour</h5>
                        <div class="candle-chart-container">
                            <canvas id="4hChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="connection-status" class="disconnected">Disconnected</div>
    </div>

    <!-- Load scripts from CDN with fallbacks -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-financial@1.0.0/dist/chartjs-plugin-financial.min.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            symbol: 'btcusdt',
            endpoints: {
                spot: [
                    'wss://stream.binance.com:9443/ws/btcusdt@aggTrade',
                    'wss://stream.binance.com:443/ws/btcusdt@aggTrade'
                ],
                futures: [
                    'wss://fstream.binance.com/ws/btcusdt@aggTrade',
                    'wss://fstream.binance.com:443/ws/btcusdt@aggTrade'
                ]
            },
            timeframes: {
                '5m': 5 * 60 * 1000,
                '15m': 15 * 60 * 1000,
                '1h': 60 * 60 * 1000,
                '4h': 4 * 60 * 60 * 1000
            }
        };

        // Application State
        const state = {
            market: 'spot',
            websocket: null,
            trades: [],
            candles: {},
            currentStats: {},
            charts: {},
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            pingInterval: null
        };

        // Initialize the application
        function init() {
            console.log("Initializing application...");
            
            // Initialize data structures
            Object.keys(CONFIG.timeframes).forEach(tf => {
                state.candles[tf] = [];
                state.currentStats[tf] = createNewWindowStats();
            });

            // Setup UI elements
            setupEventListeners();
            setupCharts();
            connectWebSocket();
            
            // Start ping interval
            state.pingInterval = setInterval(sendPing, 30000);
        }

        function createNewWindowStats() {
            return {
                windowStart: null,
                buy: 0,
                sell: 0,
                max: -Infinity,
                min: Infinity,
                lastTradeTime: null
            };
        }

        // WebSocket Management
        function connectWebSocket() {
            console.log("Attempting WebSocket connection...");
            
            // Close existing connection
            if (state.websocket) {
                state.websocket.close();
            }

            updateStatus('Connecting...', 'reconnecting');
            
            const endpoint = CONFIG.endpoints[state.market][0];
            state.websocket = new WebSocket(endpoint);

            state.websocket.onopen = () => {
                console.log('WebSocket connected to:', endpoint);
                updateStatus('Connected', 'connected');
                state.reconnectAttempts = 0;
            };

            state.websocket.onmessage = (event) => {
                try {
                    const trade = JSON.parse(event.data);
                    processTrade(trade);
                } catch (e) {
                    console.error('Error processing trade:', e);
                }
            };

            state.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                tryFallback();
            };

            state.websocket.onclose = () => {
                console.log('WebSocket closed');
                if (state.reconnectAttempts < state.maxReconnectAttempts) {
                    updateStatus('Reconnecting...', 'reconnecting');
                    state.reconnectAttempts++;
                    setTimeout(connectWebSocket, 3000);
                } else {
                    updateStatus('Disconnected', 'disconnected');
                }
            };
        }

        function tryFallback() {
            console.log("Trying fallback endpoint...");
            updateStatus('Trying fallback...', 'reconnecting');
            const fallbackUrl = CONFIG.endpoints[state.market][1];
            
            state.websocket = new WebSocket(fallbackUrl);
            
            state.websocket.onopen = () => {
                console.log('Connected to fallback endpoint:', fallbackUrl);
                updateStatus('Connected (fallback)', 'connected');
                state.reconnectAttempts = 0;
            };
            
            state.websocket.onerror = () => {
                console.log('Fallback connection failed');
                setTimeout(connectWebSocket, 5000);
            };
        }

        function sendPing() {
            if (state.websocket && state.websocket.readyState === WebSocket.OPEN) {
                try {
                    state.websocket.send(JSON.stringify({ ping: Date.now() }));
                } catch (e) {
                    console.log('Ping failed, reconnecting...');
                    connectWebSocket();
                }
            }
        }

        // Trade Processing
        function processTrade(trade) {
            const tradeData = {
                timestamp: new Date(trade.T),
                value: parseFloat(trade.q) * parseFloat(trade.p),
                isBuy: !trade.m
            };
            state.trades.push(tradeData);

            // Update all timeframes
            Object.keys(CONFIG.timeframes).forEach(tf => {
                updateTimeframeStats(tf, tradeData);
            });

            updateUI();
        }

        function updateTimeframeStats(timeframe, trade) {
            const windowSize = CONFIG.timeframes[timeframe];
            const windowStart = new Date(Math.floor(trade.timestamp / windowSize) * windowSize);
            const stats = state.currentStats[timeframe];

            // Check if we're in a new window
            if (!stats.windowStart || windowStart > stats.windowStart) {
                // If we had previous data, create a candle
                if (stats.windowStart) {
                    createCandle(timeframe);
                }
                
                // Reset stats for new window
                state.currentStats[timeframe] = createNewWindowStats();
                state.currentStats[timeframe].windowStart = windowStart;
            }

            // Update volumes
            if (trade.isBuy) {
                state.currentStats[timeframe].buy += trade.value;
            } else {
                state.currentStats[timeframe].sell += trade.value;
            }

            // Update min/max delta
            const delta = state.currentStats[timeframe].buy - state.currentStats[timeframe].sell;
            state.currentStats[timeframe].max = Math.max(delta, state.currentStats[timeframe].max);
            state.currentStats[timeframe].min = Math.min(delta, state.currentStats[timeframe].min);
            state.currentStats[timeframe].lastTradeTime = trade.timestamp;
        }

        function createCandle(timeframe) {
            const stats = state.currentStats[timeframe];
            const delta = stats.buy - stats.sell;

            const newCandle = {
                x: stats.windowStart.getTime(),
                o: delta,
                h: stats.max,
                l: stats.min,
                c: delta,
                s: delta >= 0 ? 'rgba(40, 167, 69, 0.8)' : 'rgba(220, 53, 69, 0.8)'
            };

            state.candles[timeframe].push(newCandle);

            // Keep only last 20 candles
            if (state.candles[timeframe].length > 20) {
                state.candles[timeframe].shift();
            }

            updateChart(timeframe);
        }

        // Chart Management
        function setupCharts() {
            console.log("Setting up charts...");
            
            // Register the financial plugin
            Chart.register(Chart.Financial);

            Object.keys(CONFIG.timeframes).forEach(tf => {
                const ctx = document.getElementById(`${tf}Chart`).getContext('2d');
                
                // Destroy existing chart if it exists
                if (state.charts[tf]) {
                    state.charts[tf].destroy();
                }
                
                state.charts[tf] = new Chart(ctx, {
                    type: 'candlestick',
                    data: {
                        datasets: [{
                            label: tf,
                            data: []
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value, true);
                                    }
                                }
                            },
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: {
                                        minute: 'HH:mm'
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const data = context.raw;
                                        return [
                                            `Open: ${formatCurrency(data.o, false)}`,
                                            `High: ${formatCurrency(data.h, false)}`,
                                            `Low: ${formatCurrency(data.l, false)}`,
                                            `Close: ${formatCurrency(data.c, false)}`
                                        ];
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }

        function updateChart(timeframe) {
            if (state.charts[timeframe]) {
                state.charts[timeframe].data.datasets[0].data = state.candles[timeframe];
                state.charts[timeframe].update();
            }
        }

        // UI Updates
        function updateUI() {
            // Get latest trade window (5m)
            const stats = state.currentStats['5m'];
            const delta = stats.buy - stats.sell;

            // Update current values
            document.getElementById('current-delta').textContent = formatCurrency(delta);
            document.getElementById('current-delta').className = `delta-value ${delta >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('delta-buy').textContent = formatCurrency(stats.buy);
            document.getElementById('delta-sell').textContent = formatCurrency(stats.sell);
            
            // Update min/max
            document.getElementById('max-delta').textContent = formatCurrency(stats.max);
            document.getElementById('min-delta').textContent = formatCurrency(stats.min);
        }

        function updateStatus(text, status = 'disconnected') {
            const el = document.getElementById('connection-status');
            el.textContent = text;
            el.className = status;
        }

        // Helper Functions
        function formatCurrency(value, short = false) {
            if (value === undefined || value === null) return '--';
            if (value === Infinity || value === -Infinity) return '--';
            if (short) {
                if (Math.abs(value) >= 1000000) return '$' + (value/1000000).toFixed(1) + 'M';
                if (Math.abs(value) >= 1000) return '$' + (value/1000).toFixed(1) + 'K';
            }
            return '$' + Math.round(value);
        }

        // Event Listeners
        function setupEventListeners() {
            document.getElementById('spot-btn').addEventListener('click', () => {
                if (state.market !== 'spot') {
                    state.market = 'spot';
                    document.getElementById('spot-btn').classList.add('active');
                    document.getElementById('futures-btn').classList.remove('active');
                    resetData();
                    connectWebSocket();
                }
            });

            document.getElementById('futures-btn').addEventListener('click', () => {
                if (state.market !== 'futures') {
                    state.market = 'futures';
                    document.getElementById('futures-btn').classList.add('active');
                    document.getElementById('spot-btn').classList.remove('active');
                    resetData();
                    connectWebSocket();
                }
            });
        }

        function resetData() {
            console.log("Resetting data for market change...");
            state.trades = [];
            Object.keys(CONFIG.timeframes).forEach(tf => {
                state.candles[tf] = [];
                state.currentStats[tf] = createNewWindowStats();
                if (state.charts[tf]) {
                    state.charts[tf].data.datasets[0].data = [];
                    state.charts[tf].update();
                }
            });
        }

        // Start the application when everything is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Verify all scripts are loaded
            if (typeof Chart !== 'undefined' && typeof Chart.Financial !== 'undefined') {
                init();
            } else {
                console.error("Required libraries not loaded!");
                updateStatus("Error loading charts", "disconnected");
                // Try reloading as last resort
                setTimeout(() => location.reload(), 3000);
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (state.websocket) {
                state.websocket.close();
            }
            if (state.pingInterval) {
                clearInterval(state.pingInterval);
            }
        });
    </script>
</body>
</html>